#include "Hooks.h"
#include "Hacks.h"
#include "Chams.h"
#include "Menu.h"
#include <intrin.h>
#include "Controls.h"
#include "Interfaces.h"
#include "RenderManager.h"
#include "MiscHacks.h"
#include "CRC32.h"
#include "Utilities.h"
#include <string>;;;;;;;;;;;;;;;

Vector LastAngleAA;
#define MakePtr(cast, ptr, addValue) (cast)( (DWORD)(ptr) + (DWORD)(addValue))
// Funtion Typedefs
typedef void(__thiscall* DrawModelEx_)(void*, void*, void*, const ModelRenderInfo_t&, matrix3x4*);
typedef void(__thiscall* PaintTraverse_)(PVOID, unsigned int, bool, bool);
typedef bool(__thiscall* InPrediction_)(PVOID);
typedef void(__stdcall *FrameStageNotifyFn)(ClientFrameStage_t);
typedef void(__thiscall* RenderViewFn)(void*, CViewSetup&, CViewSetup&, int, int);

using OverrideViewFn = void(__fastcall*)(void*, void*, CViewSetup*);
typedef float(__stdcall *oGetViewModelFOV)();

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class khxqoir {
public:
	string xtwjpdps;
	string vqosri;
	khxqoir();
	void grarnmpteabquu(double yeeaixf, bool qxukvpkgsolum, string aevsuonvfk, double kjfqfjlfp, bool wxffrmbxpvsqff, string onftv);
	void ritrploudqjg(double fjremso, string hkeeuhvbdpdq, int migcxdrgdbu);
	string creorhfxpflqerbhtofpcncc(string lioymltmor, double lfqwpjnbkvewl);
	void jxmvqzuztzyuyzio(double uofeswmdeclile, int fsfyh, double rfhcsiweonxp);
	double shywunftzjstp(int csvrkyof, double xkzihxjsc, bool wbamuruk, string bsntdxpargtivqb, int zkbqdft, int ooiqnol, int ysygfndnn, string yartca);

protected:
	double oehwsyyoc;
	int lxqjvlwlbcej;
	int sprlptdfrqeq;
	double txkbtaleu;
	bool eyeelj;

	int jtxccgnatbfvrxhbn(int aeersxjsucgx, string dkcgsohap, double pkovouu, int ofvtizqv, double gitmcg, double tpcynh, bool fkagejlcobgak, double sxpzkfk, string wqgyvpgujuqhenu, bool bpveddnpgqujenv);
	void brxuhckllotvhax(string vzmyy, bool enybjjavvmymi, string cxdfe, double zzmpjnifot, bool xvzhjmyurwkh, double slgube);

private:
	bool mnypzjubltpncc;
	double uiaaavlaqsen;
	string ygrzb;
	int qhvzhmrk;
	double pqgzuytjfgej;

	string gvgflzdrnvovd(double hrpulavelip, int dlvmaliifddh, bool hpascqjlbxh);
	int dmlanktaeilajuolrfgxfxn(bool kakxrrrjnif, double ysqbwqg, bool ovlvgsw, double mbpvhtofmbero, string jsvsy, string vwonxzxby);
	string majjrpyolxzd(string bhrlfdkpdu, bool snoomkhiahyohqy, int zhxmlopbht, int hobtq, double dvnkfvbul, bool yxficqzxfofuqin);

};


string khxqoir::gvgflzdrnvovd(double hrpulavelip, int dlvmaliifddh, bool hpascqjlbxh) {
	string kzscrtdqktln = "stagwhflojfovckvzpfgbibibbpbyaknifuasjimkbwa";
	string pyupyfv = "efeninoqhytzyuswa";
	int ptupmr = 40;
	double ikgva = 39601;
	string lkogwtfmpovk = "wvsokyjvsrclwvvbvnetmpnmwwxhxstbqn";
	bool qjsvukc = false;
	string cxkwhnyvfty = "pvocfnxmieeqysrxedbkidyfsqdndabgxvgqioyqcbqnmpolxpsbqhytnapugddrasvtufnxhvbtmgshws";
	int bsxbcu = 648;
	bool waxbdirsqws = true;
	if (string("pvocfnxmieeqysrxedbkidyfsqdndabgxvgqioyqcbqnmpolxpsbqhytnapugddrasvtufnxhvbtmgshws") == string("pvocfnxmieeqysrxedbkidyfsqdndabgxvgqioyqcbqnmpolxpsbqhytnapugddrasvtufnxhvbtmgshws")) {
		int avcxscwcxn;
		for (avcxscwcxn = 81; avcxscwcxn > 0; avcxscwcxn--) {
			continue;
		}
	}
	if (string("pvocfnxmieeqysrxedbkidyfsqdndabgxvgqioyqcbqnmpolxpsbqhytnapugddrasvtufnxhvbtmgshws") == string("pvocfnxmieeqysrxedbkidyfsqdndabgxvgqioyqcbqnmpolxpsbqhytnapugddrasvtufnxhvbtmgshws")) {
		int irub;
		for (irub = 15; irub > 0; irub--) {
			continue;
		}
	}
	return string("ja");
}

int khxqoir::dmlanktaeilajuolrfgxfxn(bool kakxrrrjnif, double ysqbwqg, bool ovlvgsw, double mbpvhtofmbero, string jsvsy, string vwonxzxby) {
	bool ttlupgtodqhr = false;
	bool xervaiitjpj = true;
	double xsfsz = 10688;
	int yqyrbajn = 3145;
	double cnyygruuusjnnlq = 1585;
	int vdvgwfloseqneme = 218;
	string dukcfffukyv = "etgruigamfsbrodhqauwhqjeugnbvuxvjdyorjdhobmjuxrzabkypdqqgowlwvgoarsjz";
	if (string("etgruigamfsbrodhqauwhqjeugnbvuxvjdyorjdhobmjuxrzabkypdqqgowlwvgoarsjz") == string("etgruigamfsbrodhqauwhqjeugnbvuxvjdyorjdhobmjuxrzabkypdqqgowlwvgoarsjz")) {
		int nvvoybw;
		for (nvvoybw = 79; nvvoybw > 0; nvvoybw--) {
			continue;
		}
	}
	return 27904;
}

string khxqoir::majjrpyolxzd(string bhrlfdkpdu, bool snoomkhiahyohqy, int zhxmlopbht, int hobtq, double dvnkfvbul, bool yxficqzxfofuqin) {
	bool kndib = true;
	int xdkrud = 1516;
	bool tnsfczj = false;
	string sxlxefwdnlhzn = "fwajcfgfmdczolzaxnpnrctuqtcvngzylfdlvakdeqeqqte";
	string rqwozyxc = "ffnjvqtavefibbqnxbwkcblytknumndetblaktpcngceuzplcjkumbeegjezslodoaeovwzoqgjj";
	double yesgrqoxu = 41018;
	double kvutaqfrguukosd = 57149;
	if (true == true) {
		int vpty;
		for (vpty = 76; vpty > 0; vpty--) {
			continue;
		}
	}
	if (false != false) {
		int wsoji;
		for (wsoji = 17; wsoji > 0; wsoji--) {
			continue;
		}
	}
	if (string("fwajcfgfmdczolzaxnpnrctuqtcvngzylfdlvakdeqeqqte") != string("fwajcfgfmdczolzaxnpnrctuqtcvngzylfdlvakdeqeqqte")) {
		int xhkhuoymt;
		for (xhkhuoymt = 72; xhkhuoymt > 0; xhkhuoymt--) {
			continue;
		}
	}
	if (41018 == 41018) {
		int rp;
		for (rp = 99; rp > 0; rp--) {
			continue;
		}
	}
	if (41018 != 41018) {
		int hthc;
		for (hthc = 47; hthc > 0; hthc--) {
			continue;
		}
	}
	return string("p");
}

int khxqoir::jtxccgnatbfvrxhbn(int aeersxjsucgx, string dkcgsohap, double pkovouu, int ofvtizqv, double gitmcg, double tpcynh, bool fkagejlcobgak, double sxpzkfk, string wqgyvpgujuqhenu, bool bpveddnpgqujenv) {
	double abohfqmty = 27915;
	double evflhzjdkqa = 35554;
	int lgtgbyoxiwmw = 1693;
	bool pqylxtbi = false;
	double sxrtms = 3694;
	double tbhhcnvmb = 92876;
	double drjpainmejp = 64111;
	double vnawltmbujs = 5798;
	bool bqbkfnidqszpdur = true;
	double soklyymptbxh = 36628;
	return 23807;
}

void khxqoir::brxuhckllotvhax(string vzmyy, bool enybjjavvmymi, string cxdfe, double zzmpjnifot, bool xvzhjmyurwkh, double slgube) {
	int oqzwjpj = 1380;
	double ihlaefpwslmdw = 21123;
	bool nlorteht = false;
	int ouehdfl = 8471;
	bool oolexa = true;
	int matkbr = 2706;
	double czmzthuc = 29900;
	string vlxswdq = "srkpzliwlgtcscvjoscwtmrzoiyeygkfyojpfdjgorxcrcopnpqvoykqtdjyxnjxtuhbutznupizhjtmzfydtjaprpn";
	int tovor = 4936;
	int howaxul = 7817;
	if (7817 == 7817) {
		int brgalukttj;
		for (brgalukttj = 13; brgalukttj > 0; brgalukttj--) {
			continue;
		}
	}

}

void khxqoir::grarnmpteabquu(double yeeaixf, bool qxukvpkgsolum, string aevsuonvfk, double kjfqfjlfp, bool wxffrmbxpvsqff, string onftv) {
	bool dzogigvjmoonpp = false;
	bool juhyjcutvdb = false;
	int yhjllxpxduljuny = 3698;
	int bfnagoeqb = 1994;
	int ctrrtg = 1372;
	bool agxpwozjksc = true;
	if (1372 == 1372) {
		int mx;
		for (mx = 54; mx > 0; mx--) {
			continue;
		}
	}
	if (1994 == 1994) {
		int cglrjpnmzr;
		for (cglrjpnmzr = 85; cglrjpnmzr > 0; cglrjpnmzr--) {
			continue;
		}
	}
	if (false != false) {
		int jbazbipdaw;
		for (jbazbipdaw = 82; jbazbipdaw > 0; jbazbipdaw--) {
			continue;
		}
	}

}

void khxqoir::ritrploudqjg(double fjremso, string hkeeuhvbdpdq, int migcxdrgdbu) {
	int cabprueofrnk = 1034;
	double ukienrcwpqp = 20448;
	if (1034 == 1034) {
		int vppvz;
		for (vppvz = 76; vppvz > 0; vppvz--) {
			continue;
		}
	}
	if (1034 == 1034) {
		int vjdzllywcu;
		for (vjdzllywcu = 76; vjdzllywcu > 0; vjdzllywcu--) {
			continue;
		}
	}
	if (1034 == 1034) {
		int jlvkleuigf;
		for (jlvkleuigf = 52; jlvkleuigf > 0; jlvkleuigf--) {
			continue;
		}
	}
	if (20448 == 20448) {
		int vi;
		for (vi = 88; vi > 0; vi--) {
			continue;
		}
	}
	if (1034 == 1034) {
		int mhme;
		for (mhme = 75; mhme > 0; mhme--) {
			continue;
		}
	}

}

string khxqoir::creorhfxpflqerbhtofpcncc(string lioymltmor, double lfqwpjnbkvewl) {
	double fatatuhg = 58669;
	bool pwvufcyebhhgid = true;
	bool embhlor = false;
	bool etfzgt = true;
	bool bjwbmqncm = true;
	bool xvnylfrpcib = true;
	int anzxpnilygpbsiq = 1058;
	string cgdxsnguzdi = "jymxxnjhkhvlajernnkwwiptdyxrtjhchzfcsgy";
	if (true == true) {
		int avtzqehm;
		for (avtzqehm = 21; avtzqehm > 0; avtzqehm--) {
			continue;
		}
	}
	if (true != true) {
		int zgkhylq;
		for (zgkhylq = 96; zgkhylq > 0; zgkhylq--) {
			continue;
		}
	}
	if (true == true) {
		int rchh;
		for (rchh = 11; rchh > 0; rchh--) {
			continue;
		}
	}
	if (1058 == 1058) {
		int ufrmqw;
		for (ufrmqw = 59; ufrmqw > 0; ufrmqw--) {
			continue;
		}
	}
	return string("vzaatrploqpulldbm");
}

void khxqoir::jxmvqzuztzyuyzio(double uofeswmdeclile, int fsfyh, double rfhcsiweonxp) {
	int rdhylbdn = 728;
	double zkktctbjfhsdkmu = 43285;
	bool qjlpqhswf = false;
	string hkxpkrs = "pjxydekxaklaqdaoamtdhksibwvgchstocfwpzkquicwfwwnyvahhgasldjnvurkxxiiohlvearealqjqkgpfi";
	string btmopsmwdyjyh = "cadwlckufd";
	if (string("cadwlckufd") == string("cadwlckufd")) {
		int pqagtmyhxm;
		for (pqagtmyhxm = 34; pqagtmyhxm > 0; pqagtmyhxm--) {
			continue;
		}
	}
	if (43285 != 43285) {
		int cx;
		for (cx = 44; cx > 0; cx--) {
			continue;
		}
	}

}

double khxqoir::shywunftzjstp(int csvrkyof, double xkzihxjsc, bool wbamuruk, string bsntdxpargtivqb, int zkbqdft, int ooiqnol, int ysygfndnn, string yartca) {
	int jrjukw = 5998;
	bool rxztkms = true;
	if (5998 == 5998) {
		int hsqcgqtp;
		for (hsqcgqtp = 70; hsqcgqtp > 0; hsqcgqtp--) {
			continue;
		}
	}
	if (true == true) {
		int avzwdskr;
		for (avzwdskr = 75; avzwdskr > 0; avzwdskr--) {
			continue;
		}
	}
	return 41431;
}

khxqoir::khxqoir() {
	this->grarnmpteabquu(1614, false, string("pezghgzd"), 42082, false, string("nfndqshjaoqbogiqaqibbqjvkcsgcftbekpwzmdzkhmhdkwxbgfcuuqvugclmqqetarzqgbanggzubsfbavezcofbybeoo"));
	this->ritrploudqjg(2675, string("mwdopebmcaotflxcafwdioxollpisnrolnndplcntyzo"), 1979);
	this->creorhfxpflqerbhtofpcncc(string("jalrtkaa"), 55855);
	this->jxmvqzuztzyuyzio(32864, 325, 15837);
	this->shywunftzjstp(3543, 22551, false, string("uqrvgbgdvdmulybgqdzkxbulkaiczwvdjwsmvwmteccckhbbcdizzeqxcbpoxgifyrwboznzmeoo"), 1911, 4563, 2569, string("wxxujeskpzqvbdheke"));
	this->jtxccgnatbfvrxhbn(225, string("zeyjvwwwbwmyhbxdjryabdo"), 77813, 4034, 5280, 42964, false, 3716, string("nopshshmjggvsbpzzn"), true);
	this->brxuhckllotvhax(string("wvhmvjrkknmagontweuduspgpunvgdwctnoxzqywaghcufuphulvgkcemtbryzkbfexdbycmefpnki"), true, string("gyysuqdbjesmbpcrcbdfanwqnyqzikedkvlaretdpzbjivfcvnbrzetjfrjgqenitoqhctxhdmojipyuuacup"), 70227, true, 50294);
	this->gvgflzdrnvovd(90842, 5580, false);
	this->dmlanktaeilajuolrfgxfxn(true, 12349, false, 29458, string("fckoekdahszohmcediejxtbpysbcegqtxwmidayomvlvposxkkiwawurauwdu"), string("indhufjwdwqcksrykvxzdyvyvwxlwuurwbuhqyclpcmslmmrbvmnausnxictmcdwbjngpcwbzbzx"));
	this->majjrpyolxzd(string("wvccgjjrwlcfqqodzxertuxzfsgwbdbmwybzygqiyvwkpgrofdgmdetzpbrykpgejwypvewtbshaoyhneeezenzotzmkeuaoqhth"), false, 4088, 2449, 29425, false);
}



// Function Pointers to the originals
PaintTraverse_ oPaintTraverse;
DrawModelEx_ oDrawModelExecute;
FrameStageNotifyFn oFrameStageNotify;
OverrideViewFn oOverrideView;
RenderViewFn oRenderView;

// Hook function prototypes
void __fastcall PaintTraverse_Hooked(PVOID pPanels, int edx, unsigned int vguiPanel, bool forceRepaint, bool allowForce);
bool __stdcall Hooked_InPrediction();
void __fastcall Hooked_DrawModelExecute(void* thisptr, int edx, void* ctx, void* state, const ModelRenderInfo_t &pInfo, matrix3x4 *pCustomBoneToWorld);
bool __stdcall CreateMoveClient_Hooked(/*void* self, int edx,*/ float frametime, CUserCmd* pCmd);
// VMT Managers
namespace Hooks
{
	// VMT Managers
	Utilities::Memory::VMTManager VMTPanel; // Hooking drawing functions
	Utilities::Memory::VMTManager VMTClient; // Maybe CreateMove
	Utilities::Memory::VMTManager VMTClientMode; // CreateMove for functionality
	Utilities::Memory::VMTManager VMTModelRender; // DrawModelEx for chams
	Utilities::Memory::VMTManager VMTPrediction; // InPrediction for no vis recoil
	Utilities::Memory::VMTManager VMTPlaySound; // Autoaccept 
	Utilities::Memory::VMTManager VMTRenderView;
};

/*// Initialise all our hooks
void Hooks::Initialise()
{
// Panel hooks for drawing to the screen via surface functions
VMTPanel.Initialise((DWORD*)Interfaces::Panels);
oPaintTraverse = (PaintTraverse_)VMTPanel.HookMethod((DWORD)&PaintTraverse_Hooked, Offsets::VMT::Panel_PaintTraverse);
//Utilities::Log("Paint Traverse Hooked");

// No Visual Recoil
VMTPrediction.Initialise((DWORD*)Interfaces::Prediction);
VMTPrediction.HookMethod((DWORD)&Hooked_InPrediction, 14);
//Utilities::Log("InPrediction Hooked");

// Chams
VMTModelRender.Initialise((DWORD*)Interfaces::ModelRender);
oDrawModelExecute = (DrawModelEx_)VMTModelRender.HookMethod((DWORD)&Hooked_DrawModelExecute, Offsets::VMT::ModelRender_DrawModelExecute);
//Utilities::Log("DrawModelExecute Hooked");

// Setup ClientMode Hooks
//VMTClientMode.Initialise((DWORD*)Interfaces::ClientMode);
//VMTClientMode.HookMethod((DWORD)&CreateMoveClient_Hooked, 24);
//Utilities::Log("ClientMode CreateMove Hooked");

// Setup client hooks
VMTClient.Initialise((DWORD*)Interfaces::Client);
oCreateMove = (CreateMoveFn)VMTClient.HookMethod((DWORD)&hkCreateMove, 21);
}*/

// Undo our hooks
void Hooks::UndoHooks()
{
	VMTPanel.RestoreOriginal();
	VMTPrediction.RestoreOriginal();
	VMTModelRender.RestoreOriginal();
	VMTClientMode.RestoreOriginal();
}


// Initialise all our hooks
void Hooks::Initialise()
{
	// Panel hooks for drawing to the screen via surface functions
	VMTPanel.Initialise((DWORD*)Interfaces::Panels);
	oPaintTraverse = (PaintTraverse_)VMTPanel.HookMethod((DWORD)&PaintTraverse_Hooked, Offsets::VMT::Panel_PaintTraverse);
	//Utilities::Log("Paint Traverse Hooked");

	// No Visual Recoi	l
	VMTPrediction.Initialise((DWORD*)Interfaces::Prediction);
	VMTPrediction.HookMethod((DWORD)&Hooked_InPrediction, 14);
	//Utilities::Log("InPrediction Hooked");

	// Chams
	VMTModelRender.Initialise((DWORD*)Interfaces::ModelRender);
	oDrawModelExecute = (DrawModelEx_)VMTModelRender.HookMethod((DWORD)&Hooked_DrawModelExecute, Offsets::VMT::ModelRender_DrawModelExecute);
	//Utilities::Log("DrawModelExecute Hooked");

	// Setup ClientMode Hooks
	VMTClientMode.Initialise((DWORD*)Interfaces::ClientMode);
	VMTClientMode.HookMethod((DWORD)CreateMoveClient_Hooked, 24);



}

void MovementCorrection(CUserCmd* pCmd)
{

}

//---------------------------------------------------------------------------------------------------------
//                                         Hooked Functions
//---------------------------------------------------------------------------------------------------------

void SetClanTag(const char* tag, const char* name)//6900% paste
{
	static auto pSetClanTag = reinterpret_cast<void(__fastcall*)(const char*, const char*)>(((DWORD)Utilities::Memory::FindPattern("engine.dll", (PBYTE)"\x53\x56\x57\x8B\xDA\x8B\xF9\xFF\x15\x00\x00\x00\x00\x6A\x24\x8B\xC8\x8B\x30", "xxxxxxxxx????xxxxxx")));
	pSetClanTag(tag, name);
}
void NoClantag()
{
	SetClanTag("", "");
}

void ClanTag()
{
	static int counter = 0;
	switch (Menu::Window.MiscTab.OtherClantag.GetIndex())
	{
	case 0:
		SetClanTag("", "");
		break;
	case 1:
	{
		static int motion = 0;
		int ServerTime = (float)Interfaces::Globals->interval_per_tick * hackManager.pLocal()->GetTickBase() * 2.5;

		if (counter % 48 == 0)
			motion++;
		int value = ServerTime % 19;
		switch (value) {
		case 0:SetClanTag("s", "SENSATION"); break;
		case 1:SetClanTag("se", "SENSATION"); break;
		case 2:SetClanTag("sen", "SENSATION"); break;
		case 3:SetClanTag("sens", "SENSATION"); break;
		case 4:SetClanTag("sensa", "SENSATION"); break;
		case 5:SetClanTag("sensat", "SENSATION"); break;
		case 6:SetClanTag("sensati", "SENSATION"); break;
		case 7:SetClanTag("sensatio", "SENSATION"); break;
		case 8:SetClanTag("sensation", "SENSATION"); break;
		case 9:SetClanTag("sensation.c", "SENSATION"); break;
		case 10:SetClanTag("sensation.cc", "SENSATION"); break;
		case 11:SetClanTag("sensation.c", "SENSATION"); break;
		case 12:SetClanTag("sensation.", "SENSATION"); break;
		case 13:SetClanTag("sensation", "SENSATION"); break;
		case 14:SetClanTag("sensatio", "SENSATION"); break;
		case 15:SetClanTag("sensati", "SENSATION"); break;
		case 16:SetClanTag("sensat", "SENSATION"); break;
		case 17:SetClanTag("sensa", "SENSATION"); break;
		case 18:SetClanTag("sens", "SENSATION"); break;
		case 19:SetClanTag("sen", "SENSATION"); break;
		case 20:SetClanTag("se", "SENSATION"); break;
		case 21:SetClanTag("s", "SENSATION"); break;
		}
		counter++;
	}
	break;
	case 2:
	{
		static int motion = 0;
		int ServerTime = (float)Interfaces::Globals->interval_per_tick * hackManager.pLocal()->GetTickBase() * 3;

		if (counter % 48 == 0)
			motion++;
		int value = ServerTime % 6;
		switch (value) {
		case 0:SetClanTag("SENSATION", "SENSATION"); break;
		case 1:SetClanTag("SENSATION > VACWAVE", "SENSATION > VACWAVE"); break;
		case 2:SetClanTag("SENSATION", "SENSATION"); break;
		case 3:SetClanTag("fag", "fag"); break;
		case 4:SetClanTag("Pro Baimer", "Pro Baimer"); break;
		case 5:SetClanTag("Incredible sad", "Incredible sad"); break;
		case 6:SetClanTag("me > you", "me > you"); break;
		}
		counter++;
	}
	break;
	case 3:
		SetClanTag("zu krass $", "zu krass EAS TOP");
		break;
	}
}
HooksXD lmao;
int HooksXD::night;
int HooksXD::night2;
#include "Entities.h"
void HooksXD::XD3()
{
	CSGOClassID::CMaterialModifyControl;
	//int HooksXD::night;
	//int HooksXD::night2;

	HooksXD::night = 1;
	HooksXD::night2 = 1;
};

bool __stdcall CreateMoveClient_Hooked(/*void* self, int edx,*/ float frametime, CUserCmd* pCmd)
{

	if (!pCmd->command_number)
		return true;

	if (Interfaces::Engine->IsConnected() && Interfaces::Engine->IsInGame())
	{

		PVOID pebp;
		__asm mov pebp, ebp;
		bool* pbSendPacket = (bool*)(*(DWORD*)pebp - 0x1C);
		bool& bSendPacket = *pbSendPacket;

		if (Menu::Window.MiscTab.OtherClantag.GetIndex() > 0)
			ClanTag();

		//	CUserCmd* cmdlist = *(CUserCmd**)((DWORD)Interfaces::pInput + 0xEC);
		//	CUserCmd* pCmd = &cmdlist[sequence_number % 150];


		// Backup for safety
		Vector origView = pCmd->viewangles;
		Vector viewforward, viewright, viewup, aimforward, aimright, aimup;
		Vector qAimAngles;
		qAimAngles.Init(0.0f, pCmd->viewangles.y, 0.0f);
		AngleVectors(qAimAngles, &viewforward, &viewright, &viewup);

		// Do da hacks
		IClientEntity *pLocal = Interfaces::EntList->GetClientEntity(Interfaces::Engine->GetLocalPlayer());
		if (Interfaces::Engine->IsConnected() && Interfaces::Engine->IsInGame() && pLocal && pLocal->IsAlive())
			Hacks::MoveHacks(pCmd, bSendPacket);

		//Movement Fix
		//GameUtils::CL_FixMove(pCmd, origView);
		qAimAngles.Init(0.0f, GetAutostrafeView().y, 0.0f); // if pCmd->viewangles.x > 89, set pCmd->viewangles.x instead of 0.0f on first
		AngleVectors(qAimAngles, &viewforward, &viewright, &viewup);
		qAimAngles.Init(0.0f, pCmd->viewangles.y, 0.0f);
		AngleVectors(qAimAngles, &aimforward, &aimright, &aimup);
		Vector vForwardNorm;		Normalize(viewforward, vForwardNorm);
		Vector vRightNorm;			Normalize(viewright, vRightNorm);
		Vector vUpNorm;				Normalize(viewup, vUpNorm);

		// Original shit for movement correction
		float forward = pCmd->forwardmove;
		float right = pCmd->sidemove;
		float up = pCmd->upmove;
		if (forward > 450) forward = 450;
		if (right > 450) right = 450;
		if (up > 450) up = 450;
		if (forward < -450) forward = -450;
		if (right < -450) right = -450;
		if (up < -450) up = -450;
		pCmd->forwardmove = DotProduct(forward * vForwardNorm, aimforward) + DotProduct(right * vRightNorm, aimforward) + DotProduct(up * vUpNorm, aimforward);
		pCmd->sidemove = DotProduct(forward * vForwardNorm, aimright) + DotProduct(right * vRightNorm, aimright) + DotProduct(up * vUpNorm, aimright);
		pCmd->upmove = DotProduct(forward * vForwardNorm, aimup) + DotProduct(right * vRightNorm, aimup) + DotProduct(up * vUpNorm, aimup);

		// Angle normalisation
		if (Menu::Window.MiscTab.OtherSafeMode.GetState())
		{
			GameUtils::NormaliseViewAngle(pCmd->viewangles);


			if (pCmd->viewangles.z != 0.0f)
			{
				pCmd->viewangles.z = 0.00;
			}

			if (pCmd->viewangles.x < -89 || pCmd->viewangles.x > 89 || pCmd->viewangles.y < -180 || pCmd->viewangles.y > 180)
			{
				Utilities::Log("Having to re-normalise!");
				GameUtils::NormaliseViewAngle(pCmd->viewangles);
				Beep(750, 800); // Why does it do this
				if (pCmd->viewangles.x < -89 || pCmd->viewangles.x > 89 || pCmd->viewangles.y < -180 || pCmd->viewangles.y > 180)
				{
					pCmd->viewangles = origView;
					pCmd->sidemove = right;
					pCmd->forwardmove = forward;
				}
			}
		}

		if (pCmd->viewangles.x > 90)
		{
			pCmd->forwardmove = -pCmd->forwardmove;
		}

		if (pCmd->viewangles.x < -90)
		{
			pCmd->forwardmove = -pCmd->forwardmove;
		}

		if (bSendPacket)
			LastAngleAA = pCmd->viewangles;
	}

	if (Menu::Window.VisualsTab.NightMode.GetState()) {
		{
			static bool memes = false;
			if (memes = false)
			{
				for (MaterialHandle_t i = Interfaces::MaterialSystem->FirstMaterial(); i != Interfaces::MaterialSystem->InvalidMaterial(); i = Interfaces::MaterialSystem->NextMaterial(i))
				{
					IMaterial *pMaterial = Interfaces::MaterialSystem->GetMaterial(i);

					if (!pMaterial)
						continue;

					if (strstr(pMaterial->GetTextureGroupName(), "World")) {
						//	pMaterial->AlphaModulate(0 / 255);
						pMaterial->ColorModulate(0.1, 0.1, 0.4);
						memes = true;
					}

				}
			}

		}
	}
	else
	{

		static bool memes;
		if (memes = false)
		{

			for (MaterialHandle_t i = Interfaces::MaterialSystem->FirstMaterial(); i != Interfaces::MaterialSystem->InvalidMaterial(); i = Interfaces::MaterialSystem->NextMaterial(i))
			{
				IMaterial *pMaterial = Interfaces::MaterialSystem->GetMaterial(i);

				if (!pMaterial)
					continue;

				if (strstr(pMaterial->GetTextureGroupName(), "World")) {
					//	pMaterial->AlphaModulate(0 / 255);
					pMaterial->ColorModulate(1, 1, 1);
					memes = true;
				}

			}
		}

	}
	static bool nlag1 = false;
	static bool nlag2 = false;
	if (Menu::Window.VisualsTab.OtherNoSky.GetState())
	{
		if (!nlag1)
		{
			ConVar* NoSkybox = Interfaces::CVar->FindVar("sv_skyname"); /*No-Skybox*/
			*(float*)((DWORD)&NoSkybox->fnChangeCallback + 0xC) = NULL;
			NoSkybox->SetValue("sky_l4d_rural02_ldr");
			nlag1 = true;
		}

	}
	if (nlag1)
	{
		if (!Menu::Window.VisualsTab.OtherNoSky.GetState())
		{
			if (!nlag2)
			{
				ConVar* NoSkybox = Interfaces::CVar->FindVar("sv_skyname"); /*No-Skybox*/
				*(float*)((DWORD)&NoSkybox->fnChangeCallback + 0xC) = NULL;
				NoSkybox->SetValue("jungle");
				nlag2 = true;
			}

		}
	}
	return false;
}


float Tick = 0;
// Paint Traverse Hooked function
void __fastcall PaintTraverse_Hooked(PVOID pPanels, int edx, unsigned int vguiPanel, bool forceRepaint, bool allowForce)
{
	IClientEntity* pLocal = hackManager.pLocal();
	if (Menu::Window.MiscTab.OtherNoScopeBorder.GetState() && pLocal->IsScoped() && Interfaces::Engine->IsConnected() && Interfaces::Engine->IsInGame() && pLocal->IsAlive())
	{
		ConVar* gitgud = Interfaces::CVar->FindVar("mat_postprocess_enable");
		if (gitgud)
			gitgud->SetValue(0);

		int width, height;
		Interfaces::Engine->GetScreenSize(width, height);
		Render::Line(0, height * 0.5, width, height * 0.5, Color(0, 0, 0, 255));
		Render::Line(width * 0.5, 0, width * 0.5, height, Color(0, 0, 0, 255));
	}


	if (!strcmp("HudZoom", Interfaces::Panels->GetName(vguiPanel)) && Menu::Window.MiscTab.OtherNoScopeBorder.GetState() && pLocal->IsScoped() && Interfaces::Engine->IsConnected() && Interfaces::Engine->IsInGame() && pLocal->IsAlive())
		//KURVA BUILDNI SA TY KOKOT JEBNUTY
		return;

	oPaintTraverse(pPanels, vguiPanel, forceRepaint, allowForce);

	static unsigned int FocusOverlayPanel = 0;
	static bool FoundPanel = false;


	if (!FoundPanel)
	{
		PCHAR szPanelName = (PCHAR)Interfaces::Panels->GetName(vguiPanel);
		if (strstr(szPanelName, "MatSystemTopPanel"))
		{
			FocusOverlayPanel = vguiPanel;
			FoundPanel = true;
		}
	}
	else if (FocusOverlayPanel == vguiPanel)
	{
		{
			if (Tick > 5 && Tick < 100)
				Render::Text(10, 10, Color(255, 0, 0, 255), Render::Fonts::watermark, "FED0RA.CC");
			else if (Tick > 100 && Tick < 200)
				Render::Text(10, 10, Color(255, 0, 0, 255), Render::Fonts::watermark, "FED0RA.CC");
			else if (Tick > 200 && Tick < 300)
				Tick = 0;
			Tick += 3;
		}
		if (Menu::Window.MiscTab.LBYIndicator.GetState())
		{
			RECT scrn = Render::GetViewport();
			RECT TextSize = Render::GetTextSize(Render::Fonts::Tabs, XorStr("LBY"));

			if (pLocal->IsAlive() && Interfaces::Engine->IsInGame() && Interfaces::Engine->IsConnected()) {
				if (pLocal->GetVelocity().Length2D() > 0) {
					Render::Text(10, scrn.bottom - 104.5, Color(255, 0, 0, 255), Render::Fonts::Tabs, XorStr("LBY"));
				}
				else {
					Render::Text(10, scrn.bottom - 104.5, Color(0, 255, 0, 255), Render::Fonts::Tabs, XorStr("LBY"));
				}
			}
		}
		if (Interfaces::Engine->IsConnected() && Interfaces::Engine->IsInGame())
			Hacks::DrawHacks();

		// Update and draw the menu
		Menu::DoUIFrame();
	}
}

// InPrediction Hooked Function
bool __stdcall Hooked_InPrediction()
{
	bool result;
	static InPrediction_ origFunc = (InPrediction_)Hooks::VMTPrediction.GetOriginalFunction(14);
	static DWORD *ecxVal = Interfaces::Prediction;
	result = origFunc(ecxVal);

	// If we are in the right place where the player view is calculated
	// Calculate the change in the view and get rid of it
	if (Menu::Window.VisualsTab.OtherNoVisualRecoil.GetState() && (DWORD)(_ReturnAddress()) == Offsets::Functions::dwCalcPlayerView)
	{
		IClientEntity* pLocalEntity = NULL;

		float* m_LocalViewAngles = NULL;

		__asm
		{
			MOV pLocalEntity, ESI
			MOV m_LocalViewAngles, EBX
		}

		Vector viewPunch = pLocalEntity->localPlayerExclusive()->GetViewPunchAngle();
		Vector aimPunch = pLocalEntity->localPlayerExclusive()->GetAimPunchAngle();

		m_LocalViewAngles[0] -= (viewPunch[0] + (aimPunch[0] * 2 * 0.4499999f));
		m_LocalViewAngles[1] -= (viewPunch[1] + (aimPunch[1] * 2 * 0.4499999f));
		m_LocalViewAngles[2] -= (viewPunch[2] + (aimPunch[2] * 2 * 0.4499999f));
		return true;
	}

	return result;
}

// DrawModelExec for chams and shit
void __fastcall Hooked_DrawModelExecute(void* thisptr, int edx, void* ctx, void* state, const ModelRenderInfo_t &pInfo, matrix3x4 *pCustomBoneToWorld)
{
	Color color;
	float flColor[3] = { 0.f };
	static IMaterial* CoveredLit = CreateMaterial(true);
	static IMaterial* OpenLit = CreateMaterial(false);
	static IMaterial* CoveredFlat = CreateMaterial(true, false);
	static IMaterial* OpenFlat = CreateMaterial(false, false);
	bool DontDraw = false;

	const char* ModelName = Interfaces::ModelInfo->GetModelName((model_t*)pInfo.pModel);
	IClientEntity* pModelEntity = (IClientEntity*)Interfaces::EntList->GetClientEntity(pInfo.entity_index);
	IClientEntity* pLocal = (IClientEntity*)Interfaces::EntList->GetClientEntity(Interfaces::Engine->GetLocalPlayer());

	if (Menu::Window.VisualsTab.Active.GetState())
	{
		// Player Chams
		int ChamsStyle = Menu::Window.VisualsTab.OptionsChams.GetIndex();
		int HandsStyle = Menu::Window.VisualsTab.OtherNoHands.GetIndex();
		if (ChamsStyle != 0 && Menu::Window.VisualsTab.FiltersPlayers.GetState() && strstr(ModelName, "models/player"))
		{
			if (pLocal)
			{
				IMaterial *covered = ChamsStyle == 1 ? CoveredLit : CoveredFlat;
				IMaterial *open = ChamsStyle == 1 ? OpenLit : OpenFlat;

				IClientEntity* pModelEntity = (IClientEntity*)Interfaces::EntList->GetClientEntity(pInfo.entity_index);
				if (pModelEntity)
				{
					IClientEntity *local = Interfaces::EntList->GetClientEntity(Interfaces::Engine->GetLocalPlayer());
					if (local)
					{
						if (pModelEntity->IsAlive() && pModelEntity->GetHealth() > 0 /*&& pModelEntity->GetTeamNum() != local->GetTeamNum()*/)
						{
							float alpha = 1.f;

							if (pModelEntity->HasGunGameImmunity())
								alpha = 0.5f;

							if (pModelEntity->GetTeamNum() == 2)
							{
								flColor[0] = Menu::Window.ColorTab.TColorNoVisR.GetValue() / 255.f;
								flColor[1] = Menu::Window.ColorTab.TColorNoVisG.GetValue() / 255.f;
								flColor[2] = Menu::Window.ColorTab.TColorNoVisB.GetValue() / 255.f;
							}
							else
							{
								flColor[0] = Menu::Window.ColorTab.CTColorNoVisR.GetValue() / 255.f;
								flColor[1] = Menu::Window.ColorTab.CTColorNoVisG.GetValue() / 255.f;
								flColor[2] = Menu::Window.ColorTab.CTColorNoVisB.GetValue() / 255.f;
							}

							Interfaces::RenderView->SetColorModulation(flColor);
							Interfaces::RenderView->SetBlend(alpha);
							Interfaces::ModelRender->ForcedMaterialOverride(covered);
							oDrawModelExecute(thisptr, ctx, state, pInfo, pCustomBoneToWorld);

							if (pModelEntity->GetTeamNum() == 2)
							{
								flColor[0] = Menu::Window.ColorTab.TColorVisR.GetValue() / 255.f;
								flColor[1] = Menu::Window.ColorTab.TColorVisG.GetValue() / 255.f;
								flColor[2] = Menu::Window.ColorTab.TColorVisB.GetValue() / 255.f;
							}
							else
							{
								flColor[0] = Menu::Window.ColorTab.CTColorVisR.GetValue() / 255.f;
								flColor[1] = Menu::Window.ColorTab.CTColorVisG.GetValue() / 255.f;
								flColor[2] = Menu::Window.ColorTab.CTColorVisB.GetValue() / 255.f;
							}

							Interfaces::RenderView->SetColorModulation(flColor);
							Interfaces::RenderView->SetBlend(alpha);
							Interfaces::ModelRender->ForcedMaterialOverride(open);
						}
						else
						{
							color.SetColor(255, 255, 255, 255);
							ForceMaterial(open, color);
						}
					}
				}
			}
		}
		else if (HandsStyle != 0 && strstr(ModelName, "arms"))
		{
			//int HandsBlend = Menu::Window.VisualsTab.HandsBlend.GetValue();
			if (HandsStyle == 1)
			{
				DontDraw = true;
			}
			else if (HandsStyle == 2)
			{
				IMaterial *open = ChamsStyle == 1 ? OpenLit : OpenFlat;
				int HandsR = Menu::Window.ColorTab.HandsR.GetValue();
				int HandsG = Menu::Window.ColorTab.HandsG.GetValue();
				int HandsB = Menu::Window.ColorTab.HandsB.GetValue();
				color.SetColor(HandsR, HandsG, HandsB, 70);

				ForceMaterial(open, color);
				Interfaces::ModelRender->ForcedMaterialOverride(OpenLit);
				Interfaces::RenderView->SetBlend(0.35);
			}
			else if (HandsStyle == 3)
			{
				IMaterial *covered = ChamsStyle == 1 ? OpenLit : OpenFlat;
				IMaterial *open = ChamsStyle == 1 ? OpenLit : OpenFlat;
				int HandsR = Menu::Window.ColorTab.HandsR.GetValue();
				int HandsG = Menu::Window.ColorTab.HandsG.GetValue();
				int HandsB = Menu::Window.ColorTab.HandsB.GetValue();

				if (pLocal)
				{
					if (pLocal->IsAlive())
					{
						int alpha = pLocal->HasGunGameImmunity() ? 150 : 255;

						if (pLocal->GetTeamNum() == 2)
							color.SetColor(HandsR, HandsG, HandsB, 255);
						else
							color.SetColor(HandsR, HandsG, HandsB, 255);

						ForceMaterial(covered, color);
						oDrawModelExecute(thisptr, ctx, state, pInfo, pCustomBoneToWorld);

						if (pLocal->GetTeamNum() == 2)
							color.SetColor(HandsR, HandsG, HandsB, 255);
						else
							color.SetColor(HandsR, HandsG, HandsB, 255);
					}
					else
					{
						color.SetColor(255, 255, 255, 255);
					}

					ForceMaterial(open, color);
					Interfaces::ModelRender->ForcedMaterialOverride(OpenLit);
					Interfaces::RenderView->SetBlend(1);
				}
			}
			else if (Menu::Window.VisualsTab.OtherNoHands.GetIndex() == 4)
			{
				static int counter = 0;
				static float colors[3] = { 1.f, 0.f, 0.f };

				if (colors[counter] >= 1.0f)
				{
					colors[counter] = 1.0f;
					counter += 1;
					if (counter > 2)
						counter = 0;
				}
				else
				{
					int prev = counter - 1;
					if (prev < 0) prev = 2;
					colors[prev] -= 0.05f;
					colors[counter] += 0.05f;
				}

				Interfaces::RenderView->SetColorModulation(colors);
				Interfaces::RenderView->SetBlend(1);
				Interfaces::ModelRender->ForcedMaterialOverride(OpenLit);
			}
		}
		else if (Menu::Window.VisualsTab.OtherNoHands.GetIndex() == 5)// teraz beda wireframe handy dzialac xdd 
		{

			static IMaterial* OpenFlat = CreateMaterial(true, false, true);
			static IMaterial* CoveredFlat = CreateMaterial(true, true, true);
			IMaterial *wire_weapon = ChamsStyle == 1 ? CoveredFlat : OpenFlat;

			float alpha = 1.f;

			flColor[0] = Menu::Window.ColorTab.HandsR.GetValue() / 255.f;
			flColor[1] = Menu::Window.ColorTab.HandsG.GetValue() / 255.f;
			flColor[2] = Menu::Window.ColorTab.HandsB.GetValue() / 255.f;

			Interfaces::RenderView->SetColorModulation(flColor);
			Interfaces::RenderView->SetBlend(alpha);
			Interfaces::ModelRender->ForcedMaterialOverride(wire_weapon);
			oDrawModelExecute(thisptr, ctx, state, pInfo, pCustomBoneToWorld);
		}
		else if (ChamsStyle != 0 && Menu::Window.VisualsTab.FiltersWeapons.GetState() && strstr(ModelName, "_dropped.mdl"))
		{
			IMaterial *covered = ChamsStyle == 1 ? CoveredLit : CoveredFlat;
			color.SetColor(255, 255, 255, 255);
			ForceMaterial(covered, color);
		}
	}
	if (Menu::Window.VisualsTab.WeaponChams.GetIndex() == 1 && strstr(ModelName, "models/weapons/v_") && !strstr(ModelName, "arms"))
	{
		//wepaon chams
		int ChamsStyle = Menu::Window.VisualsTab.OptionsChams.GetIndex();
		int HandsStyle = Menu::Window.VisualsTab.OtherNoHands.GetIndex();
		IMaterial *open = ChamsStyle == 1 ? OpenLit : OpenFlat;
		int WeaponR = Menu::Window.ColorTab.WeaponR.GetValue();
		int WeaponG = Menu::Window.ColorTab.WeaponG.GetValue();
		int WeaponB = Menu::Window.ColorTab.WeaponB.GetValue();
		//int WeaponBlend = Menu::Window.VisualsTab.WeaponBlend.GetValue();
		color.SetColor(WeaponR, WeaponG, WeaponB, 255);

		ForceMaterial(open, color);
		Interfaces::ModelRender->ForcedMaterialOverride(OpenLit);
		Interfaces::RenderView->SetBlend(1);
	}
	else if (Menu::Window.VisualsTab.WeaponChams.GetIndex() == 2 && strstr(ModelName, "models/weapons/v_") && !strstr(ModelName, "arms"))
	{
		color.SetColor(255, 255, 255, 255);
		int ChamsStyle = Menu::Window.VisualsTab.OptionsChams.GetIndex();
		int HandsStyle = Menu::Window.VisualsTab.OtherNoHands.GetIndex();
		IMaterial *open = ChamsStyle == 1 ? OpenLit : OpenFlat;
		ForceMaterial(open, color);
		Interfaces::ModelRender->ForcedMaterialOverride(OpenLit);
		Interfaces::RenderView->SetBlend(0.001);
	}
	else if (Menu::Window.VisualsTab.WeaponChams.GetIndex() == 3 && strstr(ModelName, "models/weapons/v_") && !strstr(ModelName, "arms"))
	{
		static int counter = 0;
		static float colors[3] = { 1.f, 0.f, 0.f };

		if (colors[counter] >= 1.0f)
		{
			colors[counter] = 1.0f;
			counter += 1;
			if (counter > 2)
				counter = 0;
		}
		else
		{
			int prev = counter - 1;
			if (prev < 0) prev = 2;
			colors[prev] -= 0.05f;
			colors[counter] += 0.05f;
		}

		Interfaces::RenderView->SetColorModulation(colors);
		Interfaces::RenderView->SetBlend(1);
		Interfaces::ModelRender->ForcedMaterialOverride(OpenLit);
	}
	else if (Menu::Window.VisualsTab.WeaponChams.GetIndex() == 4 && strstr(ModelName, "models/weapons/v_") && !strstr(ModelName, "arms"))
	{
		int WeaponR = Menu::Window.ColorTab.WeaponR.GetValue();
		int WeaponG = Menu::Window.ColorTab.WeaponG.GetValue();
		int WeaponB = Menu::Window.ColorTab.WeaponB.GetValue();
		int ChamsStyle = Menu::Window.VisualsTab.OptionsChams.GetIndex();
		int HandsStyle = Menu::Window.VisualsTab.OtherNoHands.GetIndex();
		IMaterial *open = ChamsStyle == 1 ? OpenLit : OpenFlat;
		color.SetColor(WeaponR, WeaponG, WeaponB);
		ForceMaterial(open, color);
		Interfaces::ModelRender->ForcedMaterialOverride(OpenLit);
		Interfaces::RenderView->SetBlend(0.35);
	}
	if (!DontDraw)
		oDrawModelExecute(thisptr, ctx, state, pInfo, pCustomBoneToWorld);
	Interfaces::ModelRender->ForcedMaterialOverride(NULL);
}

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class orqphah {
public:
	bool fnqgs;
	double cxdjtyztcfwa;
	string imzmtrgowb;
	bool hlvdst;
	bool aamnscp;
	orqphah();
	string tckkzmrgkwrwxe(double mbcxm, int mdwpywyvtsb, int qvswwiosaubt, bool rkxelbasjrdh);
	int tenujjwgpozhgdaslzhhsrpx(int cwaovoocsiaunh, string gwqplv, bool hugzqns, int fckxovyyxujdzho, double diphkrykcbzp, double glmdyimjzf, int ezbpyiyzvbsqa);
	void txllwyybjtv(bool hchbbra, bool lznsj, string nkqaeeurvoaiehc);
	void txybnbgxdwawdqwaaccd(int albgbuxozuplany, bool vsijg, double vigqd, string jbsepy, double atmmcpbr, int spnegjupkrrw, int puhmew, string amqlik, string qijlufkjze);
	string hjbsbiwbtjllnlqhjxi(int ruwmjtjsc, int bcvnm, bool yqbkkicsldxbz, bool owtuhbcrxskgopo, double hqxoxgrmakoiryk, int wwyhbiypox, double ifckl, int bpndzirfrxjid);

protected:
	int sjglwjiy;
	bool ejicopp;
	int yxwhrpemxilxp;
	double vvywarxju;

	int ryfofyerprboxztcvswbwwn(string bfhwzzao);
	string dowowkzhpxszehroryafqlx(string iqhzhzxxdala, int cjembclryt, bool ltlldhcxloa, int kppcr, double lveryvvfns, int ghkid, int ghljgdqsxm);
	int zrvuyrjxrblars(bool pszcfewqlyty, string ayvsa, string pzhrme, int jhkgh, bool fnfymtrczkx, string jgxiyvzypodt, bool sybjjxwp);
	string wzzexrofmwqpfhfcovgifc();
	double glltchnuxe(string pcjpyygn, int xeidgubvhdi, string wtrikzaqsbgvdyh, double rcroxrbp, bool zgysqrbmbo, string myozdkdkguv, double bjfytgbjiw, double xumfjc);

private:
	int qwxpfmnstu;
	double hzbjllllcmosk;
	bool zrfhln;
	double engsz;
	int ewnttu;

	int ycbnvtapvfw(int uqpdxorc, double ppgzpidmdukmcsn, string xoitq);
	bool elrkankbdficnsskvtffiz(int izhflaceqfkaky, bool npktzgmp, double iayropwxhiedngc, bool dbkvwyefmfmeajm, string nmpzwluiburcb, string ezflrdmnuryhrzj, string olnkqhsqd, string oqtdnowmo);
	double ecrwosgcxcknytisyftmg(double ejbhqhjspufat, bool zwqvfhjnmx, double wyhfiefmstm, bool tkxyrdirowise, bool pwheuygotfr);
	bool oedrppsunivwnnnd(bool xfsgg);
	double svfjohwvonvnpfvkqnl(string dxpvmtgy, string uzcnerjapckku, bool tcqmf, string fclxymujdpnplnt, int gcmikcsgsvdc, bool xmrrqc, bool vqoshnsvk, double txhrcjobiegi, bool xpxsgk, string iczfmrcwektmu);
	void qdvisjqhnqevdu(string khybcf);
	int lmjxefrsxsbetbjjygyhrq(int zxenfswvzm, bool klkwdxplsxdzoow, double kfpxzbow, bool eqmylszn, bool uufgsxvz, bool vofrkgqxsmobnx, bool izjtbabkwaom, bool eoczdjfn, string dnouiivzduztm);

};


int orqphah::ycbnvtapvfw(int uqpdxorc, double ppgzpidmdukmcsn, string xoitq) {
	double jmxjdnugbiqba = 19098;
	bool xidmfjatlbs = true;
	double fqrtecj = 9099;
	int egtvlthblnzd = 1505;
	int wljtkqwtyvs = 2416;
	int rimpwwaj = 6790;
	int yasgogdchtopy = 1514;
	int nsiexrr = 1074;
	int hdkufxqhdo = 2792;
	if (19098 != 19098) {
		int tujwomse;
		for (tujwomse = 57; tujwomse > 0; tujwomse--) {
			continue;
		}
	}
	if (9099 != 9099) {
		int be;
		for (be = 61; be > 0; be--) {
			continue;
		}
	}
	if (1505 != 1505) {
		int sjpeas;
		for (sjpeas = 55; sjpeas > 0; sjpeas--) {
			continue;
		}
	}
	if (1505 != 1505) {
		int xxepqwplw;
		for (xxepqwplw = 64; xxepqwplw > 0; xxepqwplw--) {
			continue;
		}
	}
	return 14203;
}

bool orqphah::elrkankbdficnsskvtffiz(int izhflaceqfkaky, bool npktzgmp, double iayropwxhiedngc, bool dbkvwyefmfmeajm, string nmpzwluiburcb, string ezflrdmnuryhrzj, string olnkqhsqd, string oqtdnowmo) {
	int sktghyqvl = 4055;
	string gpvhwwzu = "rkprdfqjxucnneyahjbbmafqqwxeokecbrtkweuyn";
	int gabcu = 3538;
	string nzias = "bpbvixucphqlvkrucjbdfwcaqgdmplbc";
	int yacnqeaim = 2329;
	int birpeeazf = 415;
	double pmqiuxq = 23801;
	bool wdztdemn = true;
	return false;
}

double orqphah::ecrwosgcxcknytisyftmg(double ejbhqhjspufat, bool zwqvfhjnmx, double wyhfiefmstm, bool tkxyrdirowise, bool pwheuygotfr) {
	string qlmptugigbkxjk = "sgggxbkwxhqtulqsbruxekhrdxx";
	double jsxgigercac = 9955;
	bool srogptzinzr = false;
	double uqsjeapekiowh = 12532;
	int ashwatnoopmlxcl = 4141;
	int xnjjlkkn = 6162;
	bool npugpomrs = true;
	string wvxotyepejfbvbn = "xqmypultknpbd";
	bool wvbsfnoxaxyj = true;
	double weeyxteauovz = 27262;
	if (12532 != 12532) {
		int yhbwqzrrx;
		for (yhbwqzrrx = 27; yhbwqzrrx > 0; yhbwqzrrx--) {
			continue;
		}
	}
	if (4141 == 4141) {
		int gu;
		for (gu = 65; gu > 0; gu--) {
			continue;
		}
	}
	if (string("sgggxbkwxhqtulqsbruxekhrdxx") != string("sgggxbkwxhqtulqsbruxekhrdxx")) {
		int yvjfmggs;
		for (yvjfmggs = 18; yvjfmggs > 0; yvjfmggs--) {
			continue;
		}
	}
	return 77881;
}

bool orqphah::oedrppsunivwnnnd(bool xfsgg) {
	string zmkvqlfmu = "wsyhfbb";
	double kmheyihszxlqq = 3874;
	string prsafdks = "ooigbrhougfonurtbkirvwfadxevhtdeczudywruikonytkmulqjfdldoquapxjerbwczmfryaamyhcpmjblt";
	if (string("ooigbrhougfonurtbkirvwfadxevhtdeczudywruikonytkmulqjfdldoquapxjerbwczmfryaamyhcpmjblt") != string("ooigbrhougfonurtbkirvwfadxevhtdeczudywruikonytkmulqjfdldoquapxjerbwczmfryaamyhcpmjblt")) {
		int htiyzij;
		for (htiyzij = 49; htiyzij > 0; htiyzij--) {
			continue;
		}
	}
	if (3874 == 3874) {
		int wqfhm;
		for (wqfhm = 90; wqfhm > 0; wqfhm--) {
			continue;
		}
	}
	return true;
}

double orqphah::svfjohwvonvnpfvkqnl(string dxpvmtgy, string uzcnerjapckku, bool tcqmf, string fclxymujdpnplnt, int gcmikcsgsvdc, bool xmrrqc, bool vqoshnsvk, double txhrcjobiegi, bool xpxsgk, string iczfmrcwektmu) {
	string weijyu = "ladlqxptoenkqgwhigschrfzivtncgffoujbcsfzzpwkoecalldgenbqvnmwhjirarocoplwjprppiomeeacmvznfwwdhhqwbm";
	bool ebswkkbv = true;
	double iszien = 76381;
	string fqtzelm = "jyswdiyhbibccblrucstfoxikgaaaycnrbscfpbwrrvlbbbpopybccqlxoeagbehyoxjfgmyfxxagaiysutxbda";
	string glauyatuwk = "xkzrbwvhnbfhaypsjzvnkrhaotctumsrlnpxcjzjxhazvvycojwhpcyrqzzjssdhpoy";
	double khadhfkmoln = 39809;
	string loakhi = "xhugksbwiotlfjfvafehgtuzzyndfmy";
	if (string("xhugksbwiotlfjfvafehgtuzzyndfmy") == string("xhugksbwiotlfjfvafehgtuzzyndfmy")) {
		int tpzckxyhxt;
		for (tpzckxyhxt = 71; tpzckxyhxt > 0; tpzckxyhxt--) {
			continue;
		}
	}
	if (string("ladlqxptoenkqgwhigschrfzivtncgffoujbcsfzzpwkoecalldgenbqvnmwhjirarocoplwjprppiomeeacmvznfwwdhhqwbm") == string("ladlqxptoenkqgwhigschrfzivtncgffoujbcsfzzpwkoecalldgenbqvnmwhjirarocoplwjprppiomeeacmvznfwwdhhqwbm")) {
		int eusgyrwtyv;
		for (eusgyrwtyv = 75; eusgyrwtyv > 0; eusgyrwtyv--) {
			continue;
		}
	}
	if (string("ladlqxptoenkqgwhigschrfzivtncgffoujbcsfzzpwkoecalldgenbqvnmwhjirarocoplwjprppiomeeacmvznfwwdhhqwbm") == string("ladlqxptoenkqgwhigschrfzivtncgffoujbcsfzzpwkoecalldgenbqvnmwhjirarocoplwjprppiomeeacmvznfwwdhhqwbm")) {
		int ztqocjrjfi;
		for (ztqocjrjfi = 93; ztqocjrjfi > 0; ztqocjrjfi--) {
			continue;
		}
	}
	if (39809 == 39809) {
		int yxwndaccks;
		for (yxwndaccks = 3; yxwndaccks > 0; yxwndaccks--) {
			continue;
		}
	}
	if (true != true) {
		int babcyrkdv;
		for (babcyrkdv = 71; babcyrkdv > 0; babcyrkdv--) {
			continue;
		}
	}
	return 4265;
}

void orqphah::qdvisjqhnqevdu(string khybcf) {
	string ktqetsybfesnbq = "skepbhbmbetngzzknoyfibfsrbftzjzvdrcuxpopurddaucolfypnjwuscfqjkb";
	double sivttg = 25769;
	bool earfrpc = true;
	int bgirtrqywhnpfy = 174;
	int qwpiabhaviqjh = 2060;
	bool fmzuqarrhcpiru = true;
	int urmuquxxfibhh = 716;
	int hrooslegcsox = 2352;
	if (2352 == 2352) {
		int hn;
		for (hn = 96; hn > 0; hn--) {
			continue;
		}
	}
	if (716 == 716) {
		int lu;
		for (lu = 28; lu > 0; lu--) {
			continue;
		}
	}

}

int orqphah::lmjxefrsxsbetbjjygyhrq(int zxenfswvzm, bool klkwdxplsxdzoow, double kfpxzbow, bool eqmylszn, bool uufgsxvz, bool vofrkgqxsmobnx, bool izjtbabkwaom, bool eoczdjfn, string dnouiivzduztm) {
	string mpgoudauordijdw = "wnpszvepfibsgvftldhgohudqlrytcxeobfrwqxjdnlzuxcnoomkiecvqzmxihwrimlrddpgbppjysgkhuxb";
	bool hlenqvbzgxlz = false;
	string uefgxogyg = "cdnnucmietittfsaanbyiahaddmnghgtkapdbbqcjlheoxioqtoyfxoqymhqakfsvwvqpltvqsxzeewvyzaa";
	string lnaruvrfqhmy = "alfmqpxzzgzjykelbbmwaroccpustmwpafnfgkpkroscpsrygf";
	int hoxdzufhuaqrq = 732;
	int jnvxkuwnp = 5093;
	int vrjhrd = 1911;
	if (string("alfmqpxzzgzjykelbbmwaroccpustmwpafnfgkpkroscpsrygf") == string("alfmqpxzzgzjykelbbmwaroccpustmwpafnfgkpkroscpsrygf")) {
		int wxvizjo;
		for (wxvizjo = 25; wxvizjo > 0; wxvizjo--) {
			continue;
		}
	}
	if (string("wnpszvepfibsgvftldhgohudqlrytcxeobfrwqxjdnlzuxcnoomkiecvqzmxihwrimlrddpgbppjysgkhuxb") != string("wnpszvepfibsgvftldhgohudqlrytcxeobfrwqxjdnlzuxcnoomkiecvqzmxihwrimlrddpgbppjysgkhuxb")) {
		int ll;
		for (ll = 42; ll > 0; ll--) {
			continue;
		}
	}
	return 33580;
}

int orqphah::ryfofyerprboxztcvswbwwn(string bfhwzzao) {
	int mkrwptfyrgp = 1944;
	int mccivhhbhnl = 1554;
	bool klhlnlbwezupqx = false;
	bool wtosupjsajb = false;
	string lzpwpvfuab = "urcibtzoggzawxa";
	int ogxpljzesu = 4938;
	bool msqkvqobhsw = true;
	string asmullzrrqkamzz = "xziplamjg";
	bool kafwum = false;
	bool ymuixyprp = false;
	return 26291;
}

string orqphah::dowowkzhpxszehroryafqlx(string iqhzhzxxdala, int cjembclryt, bool ltlldhcxloa, int kppcr, double lveryvvfns, int ghkid, int ghljgdqsxm) {
	string oalmn = "wvghtyfaullsjjgvocdkpgpyneberafwildentzqujmlairfeidwf";
	string uocdgkzkfnctg = "atmbpqnqupzqcazrxzmdabzrnktczjdowqcsauionhxlegg";
	int cwyitkomhxwr = 3802;
	double hfgzxxabmnwu = 29862;
	int yjcebuuktpzioq = 194;
	int oltenssz = 1988;
	string wqhjuzgsrgsgt = "";
	string acecaoajnq = "iavnnuxdknsorrijublagmgouzqriqovw";
	double njlyoe = 23235;
	return string("tyr");
}

int orqphah::zrvuyrjxrblars(bool pszcfewqlyty, string ayvsa, string pzhrme, int jhkgh, bool fnfymtrczkx, string jgxiyvzypodt, bool sybjjxwp) {
	string cerskoehqvr = "tkobnjueefpvyurzdjwpbctktxvvwbdbgcghylitdbodpp";
	int qrpijchchqru = 3627;
	bool fiqohdz = false;
	return 67859;
}

string orqphah::wzzexrofmwqpfhfcovgifc() {
	bool mdapfqqhexpx = false;
	if (false != false) {
		int ugka;
		for (ugka = 22; ugka > 0; ugka--) {
			continue;
		}
	}
	if (false != false) {
		int smtvaakojy;
		for (smtvaakojy = 17; smtvaakojy > 0; smtvaakojy--) {
			continue;
		}
	}
	return string("qgiokjstg");
}

double orqphah::glltchnuxe(string pcjpyygn, int xeidgubvhdi, string wtrikzaqsbgvdyh, double rcroxrbp, bool zgysqrbmbo, string myozdkdkguv, double bjfytgbjiw, double xumfjc) {
	string bvruti = "auchbrddanzttxfrmgeac";
	int ytzutjuj = 6159;
	int mjqpgsw = 3693;
	double kmopiqn = 46695;
	if (46695 != 46695) {
		int catuaxf;
		for (catuaxf = 48; catuaxf > 0; catuaxf--) {
			continue;
		}
	}
	if (string("auchbrddanzttxfrmgeac") != string("auchbrddanzttxfrmgeac")) {
		int qpsdtmoas;
		for (qpsdtmoas = 9; qpsdtmoas > 0; qpsdtmoas--) {
			continue;
		}
	}
	if (3693 == 3693) {
		int vcxfzxlfuo;
		for (vcxfzxlfuo = 70; vcxfzxlfuo > 0; vcxfzxlfuo--) {
			continue;
		}
	}
	if (string("auchbrddanzttxfrmgeac") == string("auchbrddanzttxfrmgeac")) {
		int rsyqvueal;
		for (rsyqvueal = 46; rsyqvueal > 0; rsyqvueal--) {
			continue;
		}
	}
	return 52216;
}

string orqphah::tckkzmrgkwrwxe(double mbcxm, int mdwpywyvtsb, int qvswwiosaubt, bool rkxelbasjrdh) {
	string ebvuifh = "ixglwdyjhocjiqtvuelkctkwxrdchxosggqdjniptzkzjlzsnxgwxlkprhxjmeeevqdjnevjsvwcttpqpsropgvd";
	string zkoqju = "vgxzrwwqd";
	double ntjcvbqbghaj = 11003;
	int weeejznqsr = 729;
	int udsbe = 5585;
	double pikfgryqiv = 18411;
	double ftqmiuhkosdsl = 3604;
	bool mlshfc = true;
	if (18411 == 18411) {
		int moryzrbpqu;
		for (moryzrbpqu = 51; moryzrbpqu > 0; moryzrbpqu--) {
			continue;
		}
	}
	return string("bptfiwxzj");
}

int orqphah::tenujjwgpozhgdaslzhhsrpx(int cwaovoocsiaunh, string gwqplv, bool hugzqns, int fckxovyyxujdzho, double diphkrykcbzp, double glmdyimjzf, int ezbpyiyzvbsqa) {
	return 2320;
}

void orqphah::txllwyybjtv(bool hchbbra, bool lznsj, string nkqaeeurvoaiehc) {
	double trncxfwrcfxhdh = 50292;
	double rmvtqatqzim = 19041;
	double utscsfaiaew = 27958;
	string kaqobwsqtwyqu = "mohbakodlhpsglmyatxwvxghbeitoyt";
	if (string("mohbakodlhpsglmyatxwvxghbeitoyt") == string("mohbakodlhpsglmyatxwvxghbeitoyt")) {
		int avysvuhwya;
		for (avysvuhwya = 55; avysvuhwya > 0; avysvuhwya--) {
			continue;
		}
	}
	if (19041 == 19041) {
		int akbfb;
		for (akbfb = 25; akbfb > 0; akbfb--) {
			continue;
		}
	}
	if (string("mohbakodlhpsglmyatxwvxghbeitoyt") != string("mohbakodlhpsglmyatxwvxghbeitoyt")) {
		int sdmljb;
		for (sdmljb = 21; sdmljb > 0; sdmljb--) {
			continue;
		}
	}
	if (string("mohbakodlhpsglmyatxwvxghbeitoyt") != string("mohbakodlhpsglmyatxwvxghbeitoyt")) {
		int znuka;
		for (znuka = 75; znuka > 0; znuka--) {
			continue;
		}
	}
	if (string("mohbakodlhpsglmyatxwvxghbeitoyt") == string("mohbakodlhpsglmyatxwvxghbeitoyt")) {
		int bwednk;
		for (bwednk = 29; bwednk > 0; bwednk--) {
			continue;
		}
	}

}

void orqphah::txybnbgxdwawdqwaaccd(int albgbuxozuplany, bool vsijg, double vigqd, string jbsepy, double atmmcpbr, int spnegjupkrrw, int puhmew, string amqlik, string qijlufkjze) {
	int eaoqnnz = 4411;
	if (4411 == 4411) {
		int lo;
		for (lo = 52; lo > 0; lo--) {
			continue;
		}
	}
	if (4411 == 4411) {
		int gqcevk;
		for (gqcevk = 88; gqcevk > 0; gqcevk--) {
			continue;
		}
	}

}

string orqphah::hjbsbiwbtjllnlqhjxi(int ruwmjtjsc, int bcvnm, bool yqbkkicsldxbz, bool owtuhbcrxskgopo, double hqxoxgrmakoiryk, int wwyhbiypox, double ifckl, int bpndzirfrxjid) {
	double aakynkdzphxnkwp = 1671;
	int fujdyfecuhezfxq = 2112;
	string uorfkis = "ntlkcayflphmakiqslbunmkmouiidcqwkyyjwuesaildmwuhgqurcbjsiamodxmkbytidkisgepdyfwew";
	if (string("ntlkcayflphmakiqslbunmkmouiidcqwkyyjwuesaildmwuhgqurcbjsiamodxmkbytidkisgepdyfwew") != string("ntlkcayflphmakiqslbunmkmouiidcqwkyyjwuesaildmwuhgqurcbjsiamodxmkbytidkisgepdyfwew")) {
		int xye;
		for (xye = 36; xye > 0; xye--) {
			continue;
		}
	}
	if (1671 == 1671) {
		int iw;
		for (iw = 94; iw > 0; iw--) {
			continue;
		}
	}
	if (2112 != 2112) {
		int dfjdtejh;
		for (dfjdtejh = 35; dfjdtejh > 0; dfjdtejh--) {
			continue;
		}
	}
	if (1671 != 1671) {
		int ye;
		for (ye = 4; ye > 0; ye--) {
			continue;
		}
	}
	if (1671 != 1671) {
		int efsh;
		for (efsh = 98; efsh > 0; efsh--) {
			continue;
		}
	}
	return string("ecycwosspvpidbrkvdij");
}

orqphah::orqphah() {
	this->tckkzmrgkwrwxe(32372, 3368, 917, false);
	this->tenujjwgpozhgdaslzhhsrpx(2205, string("uydwralcljygftklsbelqmkcytrtbaonojztk"), false, 1397, 32818, 10184, 6133);
	this->txllwyybjtv(true, false, string("ideso"));
	this->txybnbgxdwawdqwaaccd(394, false, 12263, string("cbwxhakythhtynkzaegbvbusyqwboqeyhbmhzrfeeugqxuplmadmcvasgnpysbprvyqsdlamf"), 57391, 2965, 1901, string("th"), string("fbcqzjudefmgpnpqdhezxycnadepwovlsphddudwiyxizwlweedcjihzzocwab"));
	this->hjbsbiwbtjllnlqhjxi(4497, 5669, false, true, 20717, 3791, 74935, 1470);
	this->ryfofyerprboxztcvswbwwn(string("rz"));
	this->dowowkzhpxszehroryafqlx(string("qdtzvqnpiwtntbqoceikynfklzsg"), 804, false, 530, 15141, 1561, 169);
	this->zrvuyrjxrblars(false, string("kgvsutigyyuzm"), string("wqnxiyiefzpsvaeotonynclrdgwnnzwlaawwrvvsgjltnslrwyzaxayzttjhbxbgsmllgjbwhrkblebvklcpurv"), 2972, false, string("uoyhvevqiqbnanoabmjnhdkhaeetgsvbsiqwdguxkbtedtynxxgwsqokuncstmjdgqsc"), false);
	this->wzzexrofmwqpfhfcovgifc();
	this->glltchnuxe(string("ltcxqmwvneyzzhzuccweunozsevysaqjrkbmfxgjfcb"), 529, string("vrpgjkffmx"), 4220, false, string("pwrbygpxfdexjzpnogtcefijunneqrhymnmdnjdfgocxzfwjvvgamk"), 24498, 21424);
	this->ycbnvtapvfw(2458, 34120, string("cmszhngtaqhsnhegimgoancaqzllbipfrxybxdavuwuwf"));
	this->elrkankbdficnsskvtffiz(6549, false, 58759, true, string("jpwlrkdymgqlepaegskkqszkgcthwpslysyfhwjbatqsjoduyqafbezetmqistovsddfuptphucukuyofcou"), string("hbhmryaarxaggzabtwtrsckihvovuquhhghoxdavjrhtpnqrfn"), string("bwicgmx"), string("ohfagexqbfbeuocfusdaenkycxybrxrgjnnnhcdhgg"));
	this->ecrwosgcxcknytisyftmg(30237, false, 52488, false, false);
	this->oedrppsunivwnnnd(false);
	this->svfjohwvonvnpfvkqnl(string("nhwakbqwheeaacfblyknuxcmioahigwzwbkzutcbzkcsuhdjulywfwpbwqmnyby"), string("fuaxuogstpulessxdgcicnhupgyhbgitkajfuflilnilpwcmytotsanotfrujxyacrbdsylweunprnixkangfzvzctpgvary"), false, string("xmnnknqvzbtkfgqvygkoaksoo"), 1784, false, false, 19642, true, string("fmxrnkazdlphyonyxpkpdbtpjhkvz"));
	this->qdvisjqhnqevdu(string("kowvvtjbrhqppgxcgrszmcndfvlvepumrjmtkghtwguayuhougqayhppg"));
	this->lmjxefrsxsbetbjjygyhrq(714, true, 29521, true, true, true, true, true, string("uehrzqzsipioioevyqaqfrodvvfamgqtnqtgqznnmpckqurxqmtismgkrbjfcks"));
}

